#Michael Higley mwh180000
#Dillon Carter	dwc180002
#Three in a row game project made for CS 2340 with Nhut Nguyen
#Registers Used:
#S Registers: s0: Stores 2d Array of board, s1: Stores size of row, s2: Stores size of column
#T Registers: t0: Stores inputted column
#
.data
	#All ASCIIZ values
	newLine:	.asciiz "\n"
	horizontalLine: .asciiz "______"
	verticalLine:	.asciiz "|"
	userWin: 	.asciiz "Congratulations, you won the game!"
	computerWin: 	.asciiz "You lost to the computer!"
	gameTie: 	.asciiz "The game has tied."
	movePrompt: 	.asciiz "It is your turn"
	computerTurn: 	.asciiz "The CPU has moved"
	inputPosition: 	.asciiz "Enter a number 1-3 for your move"
	invalidMove: 	.asciiz "That is not a valid column."
	columnFull: 	.asciiz "That column is full now"
	gameExplain: 	.asciiz "This game is called Three in a row. The goal is to get three of your pieces to line up vertically, horizontally, or diagonally. The board is 3x6 and you are up against a CPU. Have fun!."
	stateEmpty:	.asciiz "E"
	stateRed:	.asciiz "R"
	stateBlack:	.asciiz "B"
	
	#Word values
	boardState: .word 0,0,0 #Stores the state of each position in the board, 0 for empty, 1 for Play1, 2 for Play 2
		    .word 0,0,0
		    .word 0,0,0
		    .word 0,0,0
		    .word 0,0,0
		    .word 0,0,0
		   
	rowSize:   .word 3
	columnSize:.word 6
.text
main:
	li $v0, 4
	la $a0, newLine
	syscall
	
	li $v0, 4 #Loading 4 for output
	la $a0, gameExplain #Print the explanation
	syscall
	#Initialize the board
	la $s0, boardState   #load base address of 2D array into register
    	lw $s1, rowSize
    	lw $s2, columnSize
    	
loop: #Start of the input loop
	
	jal displayBoard #Display the current board
	
	li $v0, 4
	la $a0, newLine
	syscall
	
	la $a0, inputPosition
	syscall 

	li $v0, 5 #Getting ready for user input
	syscall
	
	move $t0, $v0 #Moves input to the temp register 0 
	addi $t0, $t0, -1
	jal isValid #Testing if the move is valid
	
	li $v0, 10
	syscall 
	
isValid: #Tests if the move is invalid
	blt $t0, 1, invalid
	bgt  $t0, 3, invalid

valid: #If the move is valid
	jr $ra

invalid: #If the move is invalid
	li $v0, 4
	la $a0, invalidMove
	syscall
	j loop

displayBoard: #Takes the content of each position and displays the content whether it is red, black, or empty as R, B, or E
	la $s0, boardState
	move $zero, $t6
	move $zero, $t7
	sw $ra, 0($sp)
	jal boardLoop
	lw $ra, 0($sp)
	jr $ra
	
boardLoop:    #Loops through a set amount of displays for each line of the 
	li $v0, 4	#Immediatly creates a new line
	la $a0, newLine
	syscall
	move $t7, $zero
	
	#Check current position in the board
	div $t1, $t6, 2
	mfhi $t1
	beq $t1, 1, innerLoop #Check if the remainder is equal to 1 if not, output a horizontal line
	li $v0, 4
	la $a0, horizontalLine
	syscall
	add $t6, $t6, 1 #Increment the index by 1
	blt $t6, 12, boardLoop #Compare index to total, branch back if less than

	jr $ra
	
innerLoopFinal:
	bge $t7, 3, boardLoop
	add $t6, $t6, 1 #Increment the index by 1
	lw $t2, ($s0) #Load the current value of the board state into t2
	beq $t2, 0, displayEmpty
	beq $t2, 1, displayRed
	j displayBlack
	
innerLoop:
	bge $t7, 2, innerLoopFinal
	lw $t2, ($s0) #Load the current value of the board state into t2
	beq $t2, 0, displayEmpty
	beq $t2, 1, displayRed
	j displayBlack
	
	
displayEmpty: #Displays empty board state
	li $v0, 4
	la $a0, stateEmpty
	syscall
	add $t7, $t7, 1 #Increment the inner loop index pointer
	add $s0, $s0, 4 #Increment the array by word size
	li $v0, 4	#Print out a vertical line to seperate columns
	la $a0, verticalLine
	syscall
	j innerLoop

displayRed: #Displays Red player board state
	li $v0, 4
	la $a0, stateRed
	syscall
	add $t7, $t7, 1 #Increment the inner loop index pointer
	add $s0, $s0, 4 #Increment the array by word size
	li $v0, 4	#Print out a vertical line to seperate columns
	la $a0, verticalLine
	syscall
	j innerLoop
	
displayBlack: #Displays Black player board state
	li $v0, 4
	la $a0, stateBlack
	syscall
	add $t7, $t7, 1 #Increment the inner loop index pointer
	add $s0, $s0, 4 #Increment the array by word size
	li $v0, 4	#Print out a vertical line to seperate columns
	la $a0, verticalLine
	syscall
	j innerLoop

gravityCheck: #Checks if the columns are filled, resulting address is in $t4
	#t0 is user input, $t9 is baseArrayAddress
	#address = baseArrayAddress + (rowIndex * columnSize + colIndex) * dataSize
	#address = boardstate + (userInput * 6 + 0) * 4
	la $t9, boardState #Sets $t9 to baseArrayAddress
	li $t6, 4 #$t6 is dataSize
	li $t1, 6 #$t1 is columnSize
	li $t3, 0 #$t3 is colIndex
mid:
	mult $t0, $t1 #rowIndex * columnSize
	mflo $t2 #Result in $t2
	add $t4, $t2, $t3 #(rowIndex * columnSize + colIndex)
	mult $t4, $t6 # * datasize
	mflo $t4 #Stored in $t4
	add $t4, $t4, $t9 #Stores baseArrayAddress + (rowIndex * columnSize + colIndex)
	lw $t6, 0($t4) #Gets the value at the address $t4 stored in $t6
	bgt $t6, 0, gravityIncrement
	
gravityIncrement:
	addi $t3, $t3, 1
	j mid